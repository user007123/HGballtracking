<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>HoverGreens Vision â€” Stable Lock & Trace (Baseline)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  body{margin:0;background:#000;color:#fff;font-family:Arial,sans-serif;text-align:center}
  header{padding:10px;display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap}
  button{background:#111;color:#fff;border:1px solid #333;border-radius:8px;padding:6px 12px;cursor:pointer}
  button:hover{border-color:#00ff88}
  #status{color:#00ff9c;font-size:14px}
  video{display:none}
  canvas{display:block;margin:8px auto;background:#000}
  #view{width:1180px;height:370px}
  #proc{display:none}
</style>
</head>
<body>

<header>
  <button id="resetBtn">Reset</button>
  <div id="status">Initializing cameraâ€¦</div>
</header>

<video id="cam" autoplay playsinline muted></video>
<canvas id="proc" width="960" height="540"></canvas>
<canvas id="view" width="1180" height="370"></canvas>

<script>
/* === DOM === */
const vid=document.getElementById("cam");
const proc=document.getElementById("proc"), pctx=proc.getContext("2d",{willReadFrequently:true});
const view=document.getElementById("view"), vctx=view.getContext("2d",{willReadFrequently:true});
const statusEl=document.getElementById("status");
const resetBtn=document.getElementById("resetBtn");

/* === TUNING (from your measurements) === */
const BRIGHT_MIN=200;   // ball very bright
const SAT_MAX=0.12;     // ball near-white (low saturation)
const ROI_SIZE=40;      // constant tiny ROI
const STOP_EPS=1.0;     // movement threshold (px)
const STOP_FRAMES=6;    // frames under threshold to count as stop
const GHOST_HOLD=5000;  // ms hold time for frozen trace

/* === STATE === */
let roi=null;                     // {x,y} top-left of constant ROI
let tracking=false;
let trail=[];                     // [{x,y}]
let lastBall=null;
let still=0;
let stopTime=null;
let lastFrame=null;               // frozen video frame during replay
let lostFrames=0;                 // tolerate brief dropouts

/* === HELPERS === */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
function toProc(x,y){ // view -> proc coords (note: view is mirrored, proc is not)
  return {
    px:(view.width - x) * (proc.width / view.width),
    py: y * (proc.height / view.height)
  };
}

/* === CAMERA === */
navigator.mediaDevices.getUserMedia({
  video:{ width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30}, facingMode:"environment" },
  audio:false
}).then(s=>{
  vid.srcObject=s;
  vid.onloadedmetadata=()=>{ vid.play(); statusEl.textContent="âœ… Click directly on the ball to lock"; loop(); };
}).catch(e=>{
  statusEl.textContent="âŒ Camera blocked â€” allow permissions & use HTTPS";
  console.error(e);
});

/* === RESET === */
function resetAll(){
  roi=null; tracking=false; trail=[]; lastBall=null;
  still=0; stopTime=null; lastFrame=null; lostFrames=0;
  statusEl.textContent="â†º Reset â€” click ball to lock";
}
resetBtn.onclick=resetAll;

/* === CLICK TO LOCK BALL === */
view.addEventListener("click", (e)=>{
  const r=view.getBoundingClientRect();
  const x=(e.clientX-r.left)*(view.width/r.width);
  const y=(e.clientY-r.top)*(view.height/r.height);
  resetAll();
  roi={ x:x-ROI_SIZE/2, y:y-ROI_SIZE/2 };  // constant ROI
  statusEl.textContent="ðŸŽ¯ Locked â€” roll the ball";
});

/* === BALL DETECTION IN CONSTANT ROI === */
function findBallInROI(){
  if(!roi) return null;

  // map ROI to proc coords
  const pr=toProc(roi.x, roi.y);
  const sx=Math.floor(pr.px), sy=Math.floor(pr.py);
  const sw=Math.floor(ROI_SIZE*(proc.width/view.width));
  const sh=Math.floor(ROI_SIZE*(proc.height/view.height));

  // draw full video to proc, then sample ROI
  pctx.drawImage(vid,0,0,proc.width,proc.height);
  if(sw<1||sh<1||sx<0||sy<0||sx+sw>proc.width||sy+sh>proc.height) return null;

  const img=pctx.getImageData(sx,sy,sw,sh).data;

  // collect bright, low-sat pixels
  let sumX=0,sumY=0,count=0;
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;

  for(let i=0;i<img.length;i+=4){
    const R=img[i],G=img[i+1],B=img[i+2];
    const bright=(R+G+B)/3;
    const sat=(Math.max(R,G,B)-Math.min(R,G,B))/(Math.max(R,G,B)+1);

    if(bright>BRIGHT_MIN && sat<SAT_MAX){
      const px=(i/4)%sw, py=Math.floor((i/4)/sw);
      sumX+=px; sumY+=py; count++;
      if(px<minX)minX=px; if(px>maxX)maxX=px;
      if(py<minY)minY=py; if(py>maxY)maxY=py;
    }
  }

  if(count<3 || count>300) return null;

  // shape sanity (reject big/elongated putter flashes)
  const w=maxX-minX, h=maxY-minY;
  if(w>30 || h>30) return null;
  const roundness=Math.abs(w-h)/Math.max(w,h||1);
  if(roundness>0.65) return null;

  // centroid (proc space) -> view (mirrored) space
  const cx_proc = sx + (sumX/count);
  const cy_proc = sy + (sumY/count);
  const vx=view.width/proc.width, vy=view.height/proc.height;
  const cx_view = view.width - (cx_proc * vx);
  const cy_view = cy_proc * vy;

  return { x:cx_view, y:cy_view };
}

/* === DRAW TRAIL === */
function drawTrail(){
  if(trail.length<2) return;
  vctx.strokeStyle="#00ff80";
  vctx.lineWidth=4;
  vctx.beginPath();
  vctx.moveTo(trail[0].x, trail[0].y);
  for(let i=1;i<trail.length;i++){
    vctx.lineTo(trail[i].x, trail[i].y);
  }
  vctx.stroke();
}

/* === MAIN LOOP === */
function loop(){
  requestAnimationFrame(loop);
  const now=performance.now();

  // If weâ€™re in replay-hold, show frozen frame + trail and bail
  if(stopTime && now - stopTime < GHOST_HOLD){
    if(lastFrame) vctx.putImageData(lastFrame,0,0);
    drawTrail();
    return;
  }

  // Live video (mirrored)
  vctx.save(); vctx.scale(-1,1);
  vctx.drawImage(vid, -view.width, 0, view.width, view.height);
  vctx.restore();

  // Always draw current trail
  drawTrail();

  // Draw ROI box if present
  if(roi){
    vctx.strokeStyle="#00ff88"; vctx.lineWidth=2;
    vctx.strokeRect(roi.x, roi.y, ROI_SIZE, ROI_SIZE);
  }

  // Try to find ball in the constant ROI
  const ball=findBallInROI();

  if(ball){
    // Start tracking on first detection
    if(!tracking){
      tracking=true;
      statusEl.textContent="ðŸš€ Trackingâ€¦";
    }

    // Append to trail
    trail.push(ball);

    // Move ROI to keep ball centered (constant size)
    roi.x = ball.x - ROI_SIZE/2;
    roi.y = ball.y - ROI_SIZE/2;

    // Draw current ball highlight
    vctx.fillStyle="#00ff6a";
    vctx.beginPath(); vctx.arc(ball.x,ball.y,4,0,2*Math.PI); vctx.fill();

    // Save frame for replay freeze
    lastFrame = vctx.getImageData(0,0,view.width,view.height);

    // Stop detection (based on displacement a few frames back)
    if(trail.length>6){
      const d = Math.hypot(
        trail.at(-1).x - trail.at(-5).x,
        trail.at(-1).y - trail.at(-5).y
      );
      still = (d < STOP_EPS) ? still+1 : 0;
      if(still > STOP_FRAMES){
        stopTime = now;
        statusEl.textContent = "â›³ Ball stopped â€” holding trace";
        return;
      }
    }

    lastBall=ball;
    lostFrames=0;

  } else if(tracking && lastBall){
    // Brief dropout tolerance (predict small shift left)
    lostFrames++;
    if(lostFrames<=3){
      // Nudge ROI slightly left toward last known ball position
      roi.x -= 4; // adjust if roll speed differs
    } else {
      // If lost too long, end tracking (trace remains until reset / next run)
      tracking=false;
      statusEl.textContent="âš ï¸ Lost ball â€” click to re-lock if needed";
    }
  }
}
</script>
</body>
</html>
