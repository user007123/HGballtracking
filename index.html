<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>HoverGreens Vision â€” SmallBall-Only Tracking</title>
<style>
    body { margin:0; background:black; color:white; text-align:center; font-family:Arial; }
    canvas { display:block; margin:10px auto; background:black; }
    #status { margin-bottom:8px; font-size:14px; color:#7dff7d; }
</style>
</head>
<body>

<h2>HoverGreens Vision â€” Ball-Only Tracking (v2)</h2>
<div id="status">Starting cameraâ€¦</div>

<video id="cam" autoplay playsinline muted style="display:none"></video>
<canvas id="view" width="1180" height="370"></canvas>

<script>
const statusEl = document.getElementById("status");
const video = document.getElementById("cam");
const canvas = document.getElementById("view");
const ctx = canvas.getContext("2d",{willReadFrequently:true});

const W=canvas.width, H=canvas.height;
const SW=640, SH=Math.round(640*(H/W)); // slightly higher res for small ball

const proc=document.createElement("canvas");
proc.width=SW; proc.height=SH;
const pctx=proc.getContext("2d",{willReadFrequently:true});

let lastGray=null, path=[], tracking=false, lastPt=null;
let speedEMA=0, stillFrames=0;

// ðŸ”¥ UPDATED thresholds for small ball + noise filtering
const MOVE_THRESHOLD = 10;
const WHITE_MIN = 160;
const MIN_AREA = 12;   // was 40 â€” ball smaller
const MAX_AREA = 800;
const GREEN_BIAS_MAX = 1.35;

// âœ… Start box (RIGHT SIDE, centered vertically)
const startBox = {
  x: W*0.70,   // moved right
  y: H*0.45,   // middle vertically
  w: W*0.15,
  h: H*0.25
};

navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:false})
.then(stream=>{
  video.srcObject=stream;
  video.onloadedmetadata=()=>{
    video.play();
    statusEl.textContent="ðŸ“· Ready â€” ball must start in right green zone";
    requestAnimationFrame(loop);
  };
});

function toGray(buf){
  const g=new Uint8Array(buf.length/4);
  for(let i=0,j=0;i<buf.length;i+=4,j++){
    g[j]=(0.2126*buf[i]+0.7152*buf[i+1]+0.0722*buf[i+2])|0;
  }
  return g;
}

function detectBall(curr,prev){
  if(!prev) return null;
  let sx=0,sy=0,count=0;

  for(let y=0,i=0;y<SH;y++){
    for(let x=0;x<SW;x++,i++){
      const d=Math.abs(curr[i]-prev[i]);
      if(d<MOVE_THRESHOLD) continue;

      const px=pctx.getImageData(x,y,1,1).data;
      const r=px[0],g=px[1],b=px[2];
      const brightness=(r+g+b)/3;

      if(brightness<WHITE_MIN) continue;
      const greenBias=g/((r+b)/2+1);
      if(greenBias>GREEN_BIAS_MAX) continue;

      sx+=x; sy+=y; count++;
    }
  }

  if(count<MIN_AREA||count>MAX_AREA) return null;
  return {x:sx/count,y:sy/count,area:count};
}

function loop(){
  ctx.save();
  ctx.scale(-1,1);  // âœ… MIRROR VIDEO
  ctx.drawImage(video,-W,0,W,H);
  ctx.restore();

  pctx.drawImage(video,0,0,SW,SH);
  const frame=pctx.getImageData(0,0,SW,SH);
  const gray=toGray(frame.data);

  // draw start box
  ctx.strokeStyle="#00ff88"; ctx.lineWidth=3;
  ctx.strokeRect(startBox.x,startBox.y,startBox.w,startBox.h);

  const ball = lastGray ? detectBall(gray,lastGray) : null;

  if(ball){
    const x=ball.x*(W/SW), y=ball.y*(H/SH);
    const inStart = x>startBox.x && x<startBox.x+startBox.w &&
                    y>startBox.y && y<startBox.y+startBox.h;

    if(!tracking){
      if(inStart){
        tracking=true;
        statusEl.textContent="ðŸš€ Ball detected â€” roll!";
      }
    } else {
      if(lastPt){
        const dist=Math.hypot(x-lastPt.x,y-lastPt.y);
        const speed=dist*30;
        speedEMA=0.2*speed+0.8*speedEMA;

        if(dist>1.2) path.push({x,y});
        if(speedEMA<4){stillFrames++;} else stillFrames=0;

        if(stillFrames>6){
          tracking=false;
          ctx.strokeStyle="#00ffff"; ctx.lineWidth=4;
          ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.stroke();
          statusEl.textContent="â›³ Ball stopped";
        }
      }
      lastPt={x,y};
      ctx.fillStyle="#00ff6a";
      ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill();
    }
  }

  if(path.length>1){
    ctx.strokeStyle="#00ff80"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y);
    for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y);
    ctx.stroke();
  }

  lastGray=gray;
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
