<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>HoverGreens Vision â€” Forward-Lock Ball Tracker v1.6</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root { color-scheme:dark }
body{
  margin:0;background:#000;color:#fff;
  font-family:Arial;text-align:center;
}
header{
  padding:10px;display:flex;gap:10px;
  justify-content:center;align-items:center;flex-wrap:wrap;
}
button{
  background:#111;color:#fff;border:1px solid #333;
  padding:6px 12px;border-radius:8px;cursor:pointer;
}
button:hover{border-color:#00ff88;}
#status{color:#00ff9c;font-size:14px;}
video{display:none;}
canvas{display:block;margin:8px auto;background:#000;}
#view{width:1180px;height:370px;}
#proc{display:none;}
</style>
</head>
<body>

<header>
  <button id="resetBtn">Reset</button>
  <div id="status">Initializing cameraâ€¦</div>
</header>

<video id="cam" autoplay playsinline muted></video>
<canvas id="proc" width="960" height="540"></canvas>
<canvas id="view" width="1180" height="370"></canvas>

<script>
/* ---------- DOM ---------- */
const vid=document.getElementById("cam");
const proc=document.getElementById("proc"),pctx=proc.getContext("2d",{willReadFrequently:true});
const view=document.getElementById("view"),vctx=view.getContext("2d",{willReadFrequently:true});
const statusEl=document.getElementById("status");
const resetBtn=document.getElementById("resetBtn");

/* ---------- PARAMS ---------- */
const BRIGHT_MIN=200,SAT_MAX=0.12;
const ROI_SMALL=40, ROI_LAUNCH=200;
const STOP_EPS=1.2, STOP_FRAMES=5;
const LAUNCH_SPEED=6.0;
const GHOST_HOLD=5000;

/* ---------- STATE ---------- */
let roi={x:0,y:0,width:ROI_SMALL,height:ROI_SMALL};
let tracking=false,trail=[],buf=[],kal=null,still=0;
let lastBall=null,lastVel=0,lostFrames=0,stopTime=null,frames=0;
let lastFrame=null;

/* ---------- HELPERS ---------- */
const smooth=(a,b)=>!a?b:{x:a.x*0.3+b.x*0.7,y:a.y*0.3+b.y*0.7};
function toProc(x,y){
 return {
  px:(view.width-x)*(proc.width/view.width),
  py:y*(proc.height/view.height)
 }
}

/* ---------- Camera ---------- */
navigator.mediaDevices.getUserMedia({
 video:{width:1920,height:1080,facingMode:"environment"},
 audio:false
}).then(s=>{
 vid.srcObject=s;
 vid.onloadedmetadata=()=>{vid.play();statusEl.textContent="âœ… Click ball to lock";loop();}
});

/* ---------- Reset ---------- */
function resetState(){
 roi={x:0,y:0,width:ROI_SMALL,height:ROI_SMALL};
 tracking=false;trail=[];buf=[];kal=null;still=0;
 lostFrames=0;stopTime=null;frames=0;
 statusEl.textContent="â†º Click ball to lock";
}
resetBtn.onclick=resetState;

/* ---------- Click to Lock Ball ---------- */
view.onclick=e=>{
 const r=view.getBoundingClientRect();
 const x=(e.clientX-r.left)*(view.width/r.width);
 const y=(e.clientY-r.top)*(view.height/r.height);
 resetState();
 roi.x=x-ROI_SMALL/2;
 roi.y=y-ROI_SMALL/2;
 statusEl.textContent="ðŸŽ¯ Ball locked â€” roll";
};

/* ---------- Ball Detection ---------- */
function findBall(){
 if(!roi)return null;
 const pr=toProc(roi.x,roi.y);
 const sx=Math.floor(pr.px),sy=Math.floor(pr.py);
 const sw=Math.floor(roi.width*(proc.width/view.width));
 const sh=Math.floor(roi.height*(proc.height/view.height));

 pctx.drawImage(vid,0,0,proc.width,proc.height);
 const img=pctx.getImageData(sx,sy,sw,sh).data;
 let pts=[];

 for(let i=0;i<img.length;i+=4){
  const R=img[i],G=img[i+1],B=img[i+2];
  const bright=(R+G+B)/3;
  const sat=(Math.max(R,G,B)-Math.min(R,G,B))/(Math.max(R,G,B)+1);
  if(bright>BRIGHT_MIN&&sat<SAT_MAX){
    pts.push({px:(i/4)%sw,py:Math.floor((i/4)/sw)});
  }
 }

 if(pts.length<3||pts.length>450)return null;
 const xs=pts.map(p=>p.px),ys=pts.map(p=>p.py);
 const w=Math.max(...xs)-Math.min(...xs);
 const h=Math.max(...ys)-Math.min(...ys);
 if(w>35||h>35)return null;
 if(Math.abs(w-h)/Math.max(w,h)>0.65)return null;

 const cx=pts.reduce((a,p)=>a+p.px,0)/pts.length;
 const cy=pts.reduce((a,p)=>a+p.py,0)/pts.length;
 const vx=view.width/proc.width,vy=view.height/proc.height;
 return {
  x:view.width-((sx+cx)*vx),
  y:(sy+cy)*vy
 };
}

/* ---------- Draw Trail ---------- */
function drawTrail(){
 vctx.strokeStyle="#00ff80";
 vctx.lineWidth=4;
 vctx.beginPath();
 for(let i=1;i<trail.length;i++){
  vctx.moveTo(trail[i-1].x,trail[i-1].y);
  vctx.lineTo(trail[i].x,trail[i].y);
 }
 vctx.stroke();
}

/* ---------- Main Loop ---------- */
function loop(){
 requestAnimationFrame(loop);
 const now=performance.now();

 /* Freeze & replay */
 if(stopTime && now-stopTime<GHOST_HOLD){
  vctx.putImageData(lastFrame,0,0);
  drawTrail();
  return;
 }

 /* Draw video (mirrored) */
 vctx.save();vctx.scale(-1,1);
 vctx.drawImage(vid,-view.width,0,view.width,view.height);
 vctx.restore();

 const ball=findBall();
 if(roi){
  vctx.strokeStyle="#00ff88";vctx.strokeRect(roi.x,roi.y,roi.width,roi.height);
 }
 drawTrail();

 if(ball){
  if(!tracking){tracking=true;frames=0;}
  frames++;

  let vel=lastBall?Math.hypot(ball.x-lastBall.x,ball.y-lastBall.y):0;
  lastVel=vel;lastBall=ball;

  /* Impact burst mode */
  if(vel>LAUNCH_SPEED){
    roi.width = ROI_LAUNCH;
    roi.height = ROI_SMALL;

    /* Jump ROI ahead (left) of ball */
    roi.x = ball.x - ROI_LAUNCH*0.85;
    roi.y = ball.y - ROI_SMALL/2;
  } else if(frames>6){
    /* Tight edge tracking after launch */
    roi.width = ROI_SMALL;
    roi.height = ROI_SMALL;
    roi.x = ball.x - ROI_SMALL*0.65; // lead edge track
    roi.y = ball.y - ROI_SMALL/2;
  }

  /* Kalman-ish smoothing */
  kal=smooth(kal,ball);
  buf.push(kal);
  if(buf.length>2){
    const pt=buf.shift();
    trail.push(pt);
  }

  /* draw ball dot */
  vctx.fillStyle="#00ff6a";
  vctx.beginPath();vctx.arc(ball.x,ball.y,4,0,2*Math.PI);vctx.fill();

  /* store frame for replay */
  lastFrame=vctx.getImageData(0,0,view.width,view.height);

  /* Stop detection */
  if(trail.length>8){
   const d=Math.hypot(
     trail.at(-1).x-trail.at(-6).x,
     trail.at(-1).y-trail.at(-6).y
   );
   still=d<STOP_EPS?still+1:0;
   if(still>STOP_FRAMES){
    stopTime=now;
    statusEl.textContent="â›³ Trace frozen â€” replay";
    return;
   }
  }

 } else if(tracking && lastBall){
  lostFrames++;
  if(lostFrames<3){
    roi.x -= 6; // aggressive forward predict
  } else tracking=false;
 }
}
</script>
</body>
</html>
