<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>HoverGreens Vision â€” Overhead ROI Ball Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#000; color:#fff; font-family: Arial, sans-serif; text-align:center; }
  header { padding:10px 12px; display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; }
  button { background:#111; color:#fff; border:1px solid #333; border-radius:8px; padding:6px 12px; cursor:pointer; }
  button:hover { border-color:#00ff99; }
  #status { color:#00ff9c; font-size:14px; }
  video { display:none; }
  canvas { display:block; margin:8px auto; background:#000; }
  /* Visible canvas for projection */
  #view { width:1180px; height:370px; }
  /* Hidden processing canvas (lower res to boost SNR, but high enough for tiny ball) */
  #proc { display:none; }
</style>
</head>
<body>

<header>
  <button id="resetBtn">Reset</button>
  <div id="status">Initializing cameraâ€¦ Then <b>click directly on the ball</b> to lock detection.</div>
</header>

<video id="cam" autoplay playsinline muted></video>
<canvas id="proc" width="960" height="540"></canvas>
<canvas id="view" width="1180" height="370"></canvas>

<script>
/* ========= DOM refs ========= */
const statusEl = document.getElementById("status");
const resetBtn = document.getElementById("resetBtn");
const vid  = document.getElementById("cam");
const proc = document.getElementById("proc");
const pctx = proc.getContext("2d", { willReadFrequently:true });
const view = document.getElementById("view");
const vctx = view.getContext("2d", { willReadFrequently:true });

/* ========= Tuned thresholds (from your measurements) =========
   Ball: Râ‰ˆGâ‰ˆB ~250, Brightness high, Saturation low
   Turf: dark, green, saturated
*/
const BRIGHT_MIN = 200;   // must be bright
const SAT_MAX    = 0.12;  // must be near-white
const ROI_BASE   = 80;    // initial ROI size (px)
const ROI_MIN    = 60;    // do not shrink below
const ROI_PAD    = 40;    // padding when expanding to follow ball
const BUF_DELAY  = 4;     // ~1-2 frames of â€œghostâ€ delay for nicer trail
const STOP_FRAMES = 6;    // still frames to consider ball stopped
const STOP_EPS     = 1.2; // small movement tolerance

/* ========= State ========= */
let roi = null;                 // ROI in VIEW (mirrored) space: {x,y,w,h}
let tracking = false;
let trail = [];
let kal = null;
let buf = [];
let stillCount = 0;

/* ========= Helpers ========= */
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const smooth = (a, b) => !a ? b : ({ x: a.x*0.7 + b.x*0.3, y: a.y*0.7 + b.y*0.3 });

/* ========= Camera ========= */
navigator.mediaDevices.getUserMedia({
  video: { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: "environment" },
  audio: false
}).then(stream => {
  vid.srcObject = stream;
  vid.onloadedmetadata = () => {
    vid.play();
    statusEl.textContent = "ðŸ“· Camera ready â€” click directly on the ball to lock ROI, then roll.";
    requestAnimationFrame(loop);
  };
}).catch(err => {
  statusEl.textContent = "âŒ Camera blocked. Allow camera permissions and use HTTPS.";
  console.error(err);
});

/* ========= User actions ========= */

// Click to set the tiny ROI centered on the ball
view.addEventListener("click", (e) => {
  const rect = view.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (view.width / rect.width);
  const y = (e.clientY - rect.top)  * (view.height / rect.height);

  // Create small ROI around click
  roi = { x: x - ROI_BASE/2, y: y - ROI_BASE/2, w: ROI_BASE, h: ROI_BASE };
  clampROI();
  tracking = false; trail = []; buf = []; kal = null; stillCount = 0;
  statusEl.textContent = "âœ… Ball ROI locked â€” roll!";
});

resetBtn.addEventListener("click", () => {
  tracking = false; trail = []; buf = []; kal = null; stillCount = 0; roi = null;
  statusEl.textContent = "â†º Reset. Click on the ball to lock ROI.";
});

/* ========= ROI utilities (mirroring-aware) ========= */

// Keep ROI within the view bounds
function clampROI() {
  if (!roi) return;
  roi.w = Math.max(ROI_MIN, roi.w);
  roi.h = Math.max(ROI_MIN, roi.h);
  roi.x = clamp(roi.x, 0, view.width  - roi.w);
  roi.y = clamp(roi.y, 0, view.height - roi.h);
}

// Convert ROI from VIEW (mirrored) space into PROC (unmirrored) sampling rect
// Because we draw the video mirrored on the view canvas,
// but we sample the video unmirrored on the proc canvas.
function roiViewToProcRect() {
  if (!roi) return null;
  // Mirroring: in view we see x mirrored, so the corresponding source region
  // in the unmirrored proc is flipped horizontally:
  // procX = (view.width - (roi.x + roi.w)) * (proc.width / view.width)
  const scaleX = proc.width / view.width;
  const scaleY = proc.height / view.height;
  const sx = (view.width - (roi.x + roi.w)) * scaleX;
  const sy = roi.y * scaleY;
  const sw = roi.w * scaleX;
  const sh = roi.h * scaleY;
  return { sx, sy, sw, sh };
}

/* ========= Ball detection inside a small ROI ========= */

function findBallInROI() {
  if (!roi) return null;

  // Draw latest video frame to processing canvas (unmirrored)
  pctx.drawImage(vid, 0, 0, proc.width, proc.height);

  // Sample only the ROI (converted to proc coords)
  const r = roiViewToProcRect();
  if (!r) return null;

  // Ensure ROI within proc bounds
  const sx = clamp(Math.floor(r.sx), 0, proc.width  - 1);
  const sy = clamp(Math.floor(r.sy), 0, proc.height - 1);
  const sw = clamp(Math.floor(r.sw), 1, proc.width  - sx);
  const sh = clamp(Math.floor(r.sh), 1, proc.height - sy);

  const frame = pctx.getImageData(sx, sy, sw, sh);
  const data  = frame.data;

  // Accumulate centroid of "white-ish" pixels
  let sumX = 0, sumY = 0, count = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i+1], b = data[i+2];
    const bright = (r + g + b) / 3;
    const maxC = Math.max(r, g, b), minC = Math.min(r, g, b);
    const sat = (maxC - minC) / (maxC + 1);

    if (bright > BRIGHT_MIN && sat < SAT_MAX) {
      const px = (i / 4) % sw;              // pixel x within ROI (proc space)
      const py = Math.floor((i / 4) / sw);  // pixel y within ROI (proc space)
      sumX += px; sumY += py; count++;
    }
  }

  // If there are enough candidate pixels to represent the tiny ball
  if (count >= 3 && count <= 250) {
    // Convert ROI-local (proc) centroid â†’ VIEW coords (mirrored space)
    const vxPerPx = view.width  / proc.width;
    const vyPerPx = view.height / proc.height;

    // Compute centroid in proc space
    const cx_proc = sx + (sumX / count); // absolute proc x
    const cy_proc = sy + (sumY / count); // absolute proc y

    // Map to view mirrored x:
    // viewX = view.width - (cx_proc * vxPerPx)
    const cx_view = view.width - (cx_proc * vxPerPx);
    const cy_view = cy_proc * vyPerPx;

    return { x: cx_view, y: cy_view };
  }

  return null;
}

/* ========= Main loop ========= */
function loop(){
  // Draw mirrored camera to the view canvas
  vctx.save();
  vctx.scale(-1, 1);
  vctx.drawImage(vid, -view.width, 0, view.width, view.height);
  vctx.restore();

  // Draw ROI if set
  if (roi) {
    vctx.strokeStyle = "#00ff88";
    vctx.lineWidth = 2;
    vctx.strokeRect(roi.x, roi.y, roi.w, roi.h);
  }

  // Find ball in ROI
  const ball = findBallInROI();

  if (ball) {
    // Start tracking on first valid detection
    if (!tracking) {
      tracking = true;
      trail = []; buf = []; kal = null; stillCount = 0;
      statusEl.textContent = "ðŸš€ Trackingâ€¦";
    }

    // Smooth and buffer slightly for nicer projected look
    kal = smooth(kal, ball);
    buf.push(kal);

    // Draw after a tiny delay for a â€œghostâ€ trailing effect
    if (buf.length > BUF_DELAY) {
      const pt = buf.shift();
      trail.push(pt);

      // Trail line
      if (trail.length > 1) {
        vctx.strokeStyle = "#00ff80";
        vctx.lineWidth = 4;
        vctx.beginPath();
        vctx.moveTo(trail[0].x, trail[0].y);
        for (let i = 1; i < trail.length; i++) {
          vctx.lineTo(trail[i].x, trail[i].y);
        }
        vctx.stroke();
      }

      // Expand ROI so it keeps the ball inside as it starts to roll out
      roi.x = Math.min(roi.x, pt.x - ROI_PAD);
      roi.y = Math.min(roi.y, pt.y - ROI_PAD);
      roi.w = Math.max(ROI_MIN, Math.abs(pt.x - roi.x) + ROI_PAD);
      roi.h = Math.max(ROI_MIN, Math.abs(pt.y - roi.y) + ROI_PAD);
      clampROI();

      // Stop detection: if almost no movement over several frames
      if (trail.length > 6) {
        const d = Math.hypot(
          trail.at(-1).x - trail.at(-5).x,
          trail.at(-1).y - trail.at(-5).y
        );
        if (d < STOP_EPS) {
          stillCount++;
          if (stillCount > STOP_FRAMES) {
            tracking = false;
            stillCount = 0;
            // mark stop
            const end = trail.at(-1);
            vctx.strokeStyle = "#00ffff";
            vctx.lineWidth = 4;
            vctx.beginPath();
            vctx.arc(end.x, end.y, 10, 0, 2*Math.PI);
            vctx.stroke();
            statusEl.textContent = "â›³ Ball stopped â€” click to lock a new ROI if needed.";
          }
        } else {
          stillCount = 0;
        }
      }
    }

    // Draw current ball dot
    vctx.fillStyle = "#00ff6a";
    vctx.beginPath();
    vctx.arc(ball.x, ball.y, 5, 0, 2*Math.PI);
    vctx.fill();
  }

  requestAnimationFrame(loop);
}
</script>
</body>
</html>
