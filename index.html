<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>HoverGreens Vision â€” Tiny Ball Tracker (Overhead Mode)</title>
<style>
  body{margin:0;background:#000;color:#fff;text-align:center;font-family:Arial;}
  #status{margin:6px;font-size:14px;color:#7dff7d;}
  canvas{display:block;margin:6px auto;background:#000;}
  video{display:none}
</style>
</head>
<body>

<h3>HoverGreens Vision â€” Overhead Tracker</h3>
<div id="status">Initializing cameraâ€¦</div>

<video id="cam" autoplay playsinline muted></video>
<canvas id="detect" width="960" height="540"></canvas> <!-- internal detection -->
<canvas id="project" width="1180" height="370"></canvas> <!-- projection output -->

<script>
// ------------------- setup --------------------
const statusEl=document.getElementById("status");
const video=document.getElementById("cam");
const detect=document.getElementById("detect");
const dctx=detect.getContext("2d",{willReadFrequently:true});
const project=document.getElementById("project");
const pctx=project.getContext("2d",{willReadFrequently:true});

const DW=detect.width, DH=detect.height;
let lastMask=null, kalman=null;
let path=[], tracking=false, stillCount=0, buffer=[];
const delayFrames=5; // ~80ms at 60fps

// Start box (right middle)
const startBox={
  x:project.width*0.7,
  y:project.height*0.45,
  w:project.width*0.15,
  h:project.height*0.25
};

// HSV threshold for white ball
function isBallPixel(r,g,b){
  const brightness=(r+g+b)/3;
  if(brightness<180) return false;
  const maxC=Math.max(r,g,b), minC=Math.min(r,g,b);
  const sat=(maxC-minC)/(maxC+1);
  if(sat>0.25) return false; // white-ish only
  return true;
}

// Connected blob find
function findBall(mask){
  let best=null;
  for(let y=0;y<DH;y++){
    for(let x=0;x<DW;x++){
      const i=y*DW+x;
      if(mask[i]===1){
        let sx=0,sy=0,count=0;
        const stack=[[x,y]];
        mask[i]=0;
        while(stack.length){
          const [cx,cy]=stack.pop();
          const idx=cy*DW+cx;
          sx+=cx; sy+=cy; count++;
          mask[idx]=0;
          for(const [nx,ny] of [[1,0],[-1,0],[0,1],[0,-1]]){
            const xx=cx+nx,yy=cy+ny;
            if(xx>=0&&xx<DW&&yy>=0&&yy<DH){
              const ii=yy*DW+xx;
              if(mask[ii]===1){ mask[ii]=0; stack.push([xx,yy]); }
            }
          }
        }
        if(count>8&&count<400){
          const cx=sx/count, cy=sy/count;
          best={x:cx,y:cy,size:count};
        }
      }
    }
  }
  return best;
}

// Basic kalman smoother
function kf(prev,pt){
  if(!prev) return pt;
  return {
    x: prev.x*0.7 + pt.x*0.3,
    y: prev.y*0.7 + pt.y*0.3
  };
}

// Camera on
navigator.mediaDevices.getUserMedia({video:{resolution:{width:1920,height:1080}},audio:false})
.then(stream=>{
  video.srcObject=stream;
  video.onloadedmetadata=()=>requestAnimationFrame(loop);
});

// ------------------- main loop --------------------
function loop(){
  // Read frame to detection canvas
  dctx.drawImage(video,0,0,DW,DH);
  const frame=dctx.getImageData(0,0,DW,DH);
  const data=frame.data;

  // Build binary mask for ball
  const mask=new Uint8Array(DW*DH);
  for(let i=0;i<data.length;i+=4){
    const r=data[i],g=data[i+1],b=data[i+2];
    if(isBallPixel(r,g,b)) mask[i/4]=1;
  }

  // Find blob = ball candidate
  const blob=findBall(mask.slice());
  let ballPix=null;
  if(blob){
    // convert to projection coords
    const x=blob.x*(project.width/DW);
    const y=blob.y*(project.height/DH);
    ballPix={x,y};
  }

  // Draw mirror video for projection reference
  pctx.save();
  pctx.scale(-1,1);
  pctx.drawImage(video,-project.width,0,project.width,project.height);
  pctx.restore();

  // Draw start zone
  pctx.strokeStyle="#00ff88"; pctx.lineWidth=3;
  pctx.strokeRect(startBox.x,startBox.y,startBox.w,startBox.h);

  if(ballPix){
    const inBox =
      ballPix.x>startBox.x && ballPix.x<startBox.x+startBox.w &&
      ballPix.y>startBox.y && ballPix.y<startBox.y+startBox.h;

    if(!tracking && inBox){
      tracking=true; path=[]; stillCount=0;
      statusEl.textContent="ðŸš€ Ball detected â€” roll!";
    }

    if(tracking){
      kalman=kf(kalman,ballPix);
      buffer.push(kalman);

      if(buffer.length>delayFrames){
        const pt=buffer.shift();
        path.push(pt);

        // draw green trace trail
        if(path.length>1){
          pctx.strokeStyle="#00ff80"; pctx.lineWidth=4;
          pctx.beginPath();
          pctx.moveTo(path[0].x,path[0].y);
          for(let i=1;i<path.length;i++) pctx.lineTo(path[i].x,path[i].y);
          pctx.stroke();
        }

        // detect stop
        if(path.length>4){
          const d = Math.hypot(
            path.at(-1).x - path.at(-4).x,
            path.at(-1).y - path.at(-4).y
          );
          if(d<2){
            stillCount++;
            if(stillCount>6){
              tracking=false;
              statusEl.textContent="â›³ Ball stopped";
              // blue finish circle
              const end=path.at(-1);
              pctx.strokeStyle="#00ffff"; pctx.lineWidth=4;
              pctx.beginPath(); pctx.arc(end.x,end.y,12,0,2*Math.PI); pctx.stroke();
            }
          }
        }
      }
    }
  }

  requestAnimationFrame(loop);
}
</script>
</body>
</html>
