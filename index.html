<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>HoverGreens Ball Tracer ‚Äî ASM OpenCV</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />

<style>
  body { margin:0; background:#000; color:#fff; font-family:Arial; text-align:center; }
  h2 { margin:10px 0 6px; font-size:20px; }
  #status { font-size:14px; color:#7dff7d; min-height:20px; margin-bottom:8px; }
  .row { display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-bottom:6px; }
  button { background:#111; color:#fff; border:1px solid #444; border-radius:8px; padding:8px 14px; cursor:pointer; }
  button:hover { border-color:#4cff70; }
  label { font-size:12px; color:#bbb; }
  video { display:none; }
  canvas { width:1180px; height:370px; background:#111; display:block; margin:8px auto; }
  .thumb { position:absolute; right:14px; top:14px; border:1px solid #333; width:220px; height:124px; background:#000; }
  .stage { position:relative; }
</style>

<!-- ‚úÖ Local OpenCV ASM build (no wasm needed) -->
<script src="opencv.js"></script>
<script>
let cvReady = false;
cv['onRuntimeInitialized'] = () => {
  cvReady = true;
  document.getElementById("status").innerText = "‚úÖ OpenCV Ready ‚Äî ASM Mode Loaded";
  if (typeof loop === "function") requestAnimationFrame(loop);
};
</script>
</head>
<body>

<h2>HoverGreens ‚Äî Ball Tracer (White Ball)</h2>

<div class="row">
  <button id="resetBtn">Reset</button>
  <button id="debugBtn">Debug</button>
  <label>Vmin <span id="vVal">185</span>
    <input id="vmin" type="range" min="140" max="255" step="1" value="185" />
  </label>
  <label>Smax <span id="sVal">70</span>
    <input id="smax" type="range" min="20" max="150" step="1" value="70" />
  </label>
  <label>MinArea <span id="aVal">120</span>
    <input id="amin" type="range" min="30" max="2000" step="10" value="120" />
  </label>
</div>

<div id="status">‚è≥ Initializing camera & OpenCV‚Ä¶</div>

<video id="cam" autoplay playsinline></video>

<div class="stage">
  <canvas id="view" width="1180" height="370"></canvas>
  <canvas id="maskThumb" class="thumb" width="220" height="124"></canvas>
</div>

<script>
const statusBox = document.getElementById('status');
const video     = document.getElementById('cam');
const canvas    = document.getElementById('view');
const ctx       = canvas.getContext('2d');
const maskThumb = document.getElementById('maskThumb').getContext('2d');

const vmin = document.getElementById('vmin');
const smax = document.getElementById('smax');
const amin = document.getElementById('amin');
const vVal = document.getElementById('vVal');
const sVal = document.getElementById('sVal');
const aVal = document.getElementById('aVal');

[vmin,smax,amin].forEach(inp=>{
  const map = {vmin:vVal,smax:sVal,amin:aVal}[inp.id];
  const upd = ()=> map.textContent = inp.value;
  inp.oninput = upd; upd();
});

const resetBtn = document.getElementById('resetBtn');
const debugBtn = document.getElementById('debugBtn');

let debugMode  = false;
let path = [];
let tracing = false;
let last = null;
let speedEMA = 0;
let stillCount = 0;

/* Camera feed */
navigator.mediaDevices.getUserMedia({ video:true }).then(stream=>{
  video.srcObject = stream;
  video.onloadedmetadata = ()=>video.play();
  statusBox.textContent = 'üì∑ Camera started ‚Äî waiting for OpenCV‚Ä¶';
}).catch(()=>{
  statusBox.textContent = '‚ùå Camera blocked ‚Äî enable permissions';
});

debugBtn.onclick = ()=>{
  debugMode = !debugMode;
  statusBox.textContent = debugMode ? 'üêõ Debug ON' : '‚úÖ Debug OFF';
};

resetBtn.onclick = ()=>{
  path = [];
  tracing = false;
  last = null;
  speedEMA = 0;
  stillCount = 0;
  statusBox.textContent = '‚Ü∫ Ready for next putt';
};

function detectBall() {
  let src = cv.imread(canvas);

  let hsv = new cv.Mat();
  cv.cvtColor(src, hsv, cv.COLOR_RGBA2HSV);

  let mv = new cv.MatVector();
  cv.split(hsv, mv);
  let Sc = mv.get(1), Vc = mv.get(2);

  let sMask = new cv.Mat();
  cv.threshold(Sc, sMask, +smax.value, 255, cv.THRESH_BINARY_INV);

  let vMask = new cv.Mat();
  cv.threshold(Vc, vMask, +vmin.value, 255, cv.THRESH_BINARY);

  let mask = new cv.Mat();
  cv.bitwise_and(sMask, vMask, mask);

  const K = 3;
  let kernel = cv.Mat.ones(K, K, cv.CV_8U);
  cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
  kernel.delete();

  cv.GaussianBlur(mask, mask, new cv.Size(5,5), 0);

  let cnts = new cv.MatVector(), hier = new cv.Mat();
  cv.findContours(mask, cnts, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let bestIndex = -1, bestScore = -1, bestArea = 0;
  for (let i=0;i<cnts.size();i++){
    const c = cnts.get(i);
    const area = cv.contourArea(c);
    if (area < +amin.value) continue;

    const peri = cv.arcLength(c, true);
    if (peri <= 0) continue;
    const circ = (4*Math.PI*area)/(peri*peri);

    const score = circ*1000 + area/1000;
    if (score > bestScore) { bestScore = score; bestIndex = i; bestArea = area; }
  }

  let center = null;
  if (bestIndex >= 0) {
    const m = cv.moments(cnts.get(bestIndex));
    if (m.m00 !== 0) center = { x: m.m10/m.m00, y: m.m01/m.m00, area: bestArea };
  }

  if (debugMode) {
    let small = new cv.Mat();
    cv.resize(mask, small, new cv.Size(220,124));
    let rgba = new cv.Mat();
    cv.cvtColor(small, rgba, cv.COLOR_GRAY2RGBA);
    const img = new ImageData(new Uint8ClampedArray(rgba.data), rgba.cols, rgba.rows);
    maskThumb.putImageData(img, 0, 0);
    small.delete(); rgba.delete();
  } else {
    maskThumb.clearRect(0,0,220,124);
  }

  src.delete(); hsv.delete(); mv.delete(); Sc.delete(); Vc.delete();
  sMask.delete(); vMask.delete(); mask.delete(); cnts.delete(); hier.delete();

  return center;
}

function loop(){
  ctx.save();
  ctx.scale(-1,1);
  ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
  ctx.restore();

  if (cvReady) {
    const pt = detectBall();
    if (pt) {
      ctx.strokeStyle = '#00eaff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 12, 0, Math.PI*2);
      ctx.stroke();

      const now = performance.now();
      if (last) {
        const dt = Math.max(1, (now-last.t))/1000;
        const dist = Math.hypot(pt.x-last.x, pt.y-last.y);
        const speed = dist/dt;
        speedEMA = speed*0.25 + speedEMA*0.75;

        if (!tracing && dist>1.8) {
          tracing = true;
          path = [ {...last}, {x:pt.x,y:pt.y} ];
          stillCount = 0;
          statusBox.textContent = 'üöÄ Ball moving ‚Äî tracing';
        }

        if (tracing) {
          if (dist>0.6) path.push({x:pt.x,y:pt.y});
          if (speedEMA < 5) {
            stillCount++;
            if (stillCount>12) {
              tracing = false;
              const end = path[path.length-1];
              ctx.strokeStyle = '#ff5050';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(end.x,end.y,14,0,Math.PI*2);
              ctx.stroke();
              statusBox.textContent = '‚õ≥ Ball stopped ‚Äî Reset for next putt';
            }
          } else stillCount=0;
        }
      }
      last = {x:pt.x,y:pt.y,t:now};
    }

    if (path.length>1) {
      ctx.strokeStyle = '#00ff80';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(path[0].x,path[0].y);
      for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y);
      ctx.stroke();
    }
  }

  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(50,50,8,0,Math.PI*2);
  ctx.fill();

  requestAnimationFrame(loop);
}
</script>
</body>
</html>
